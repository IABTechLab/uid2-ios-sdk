//
//  TestCryptoUtil.swift
//
//
//  Created by Dave Snabel-Caunt on 16/07/2024.
//

import CryptoKit
import Foundation
@testable import UID2

// Simple Atomic implementation for test usage
private final class Atomic<Value: Sendable>: @unchecked Sendable {

    private let lock = NSRecursiveLock()

    private var _value: Value

    var value: Value {
        get {
            lock.lock()
            defer { lock.unlock() }
            return _value
        }
        set {
            lock.lock()
            defer { lock.unlock() }
            _value = newValue
        }
    }

    init(_ value: Value) {
        _value = value
    }
}

/// A test convenience which exposes the Symmetric Key it generates for the client.
/// This key can then be used to encrypt stub responses for the client.
internal final class TestCryptoUtil {
    private let atomicSymmetricKey: Atomic<SymmetricKey?>

    /// `SymmetricKey` generated by the client, or `nil` if the key has not yet been generated.
    var symmetricKey: SymmetricKey? {
        atomicSymmetricKey.value
    }
    let cryptoUtil: CryptoUtil

    init() {
        let symmetricKey = Atomic<SymmetricKey?>(nil)
        self.atomicSymmetricKey = symmetricKey

        let crypto = CryptoUtil.liveValue
        self.cryptoUtil = CryptoUtil(
            // Use the live implementations, but grab the symmetricKey
            // so we can use it to encrypt a stub response
            parseKey: { string in
                let result = try crypto.parseKey(string)
                symmetricKey.value = result.0
                return result
            }, encrypt: { data, key, authenticatedData in
                try crypto.encrypt(data, key, authenticatedData)
            }
        )
    }
}

